// EfxMfc.cpp : Defines the initialization routines for the DLL.
//

#include "pch.h"
#include "framework.h"
#include "resource.h"		// main symbols
#include "EfxWnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


typedef	CMap<CStringA, LPCSTR, efxStockMasterItem*, efxStockMasterItem*>	CEfxStockMasterMap;
typedef	CMap<CStringW, LPCWSTR, efxStockMasterItem*, efxStockMasterItem*>	CEfxStockMasterMapW;
typedef	CMap<UINT, UINT, CEfxWnd*, CEfxWnd*>	CEfxWndMap;


// CEfxMfcApp
// See EfxMfc.cpp for the implementation of this class
//

class CEfxMfcApp : public CWinApp
{
public:
	CEfxMfcApp();

	AFX_INLINE CEfxWnd* GetEfxWnd() const { return m_pEfxWnd; }

	void SetSysMsgCallback(efxSysMsgCB fnSysMsg);
	bool LoadStockMaster();
	AFX_INLINE efxStockMasterItem* FindStockMaster(LPCSTR lpszStockCode) {
		return m_mapStockMstCode[lpszStockCode];
	}
	AFX_INLINE efxStockMasterItem* GetStockMasterAt(int seqNo) {
		return &m_arStockMaster.GetAt(seqNo);
	}

	void InsertEfxWnd(UINT uID, CEfxWnd* pEfxWnd);
	void OnEfxExit();

	static UINT		m_efxSeqNo;
	CString			m_strEfxDir;

private:
	CEfxWnd*		m_pEfxWnd;		// default CEfxWnd
	CEfxWndMap		m_mapEfxWnd;
	CWnd			m_wndEfxMain;
	CArray<efxStockMasterItem>	m_arStockMaster;
	CEfxStockMasterMap			m_mapStockMstCode;
	CEfxStockMasterMapW			m_mapStockMstName;

	// Overrides
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CEfxMfcApp, CWinApp)
END_MESSAGE_MAP()


UINT CEfxMfcApp::m_efxSeqNo = 1;

// CEfxMfcApp construction

CEfxMfcApp::CEfxMfcApp() : m_pEfxWnd(nullptr)
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
#ifdef DEBUG
	printf("efxInvestInfo size = %d\n", sizeof(efxInvestInfo));
	printf("efxStockMasterItem size = %d\n", sizeof(efxStockMasterItem));
#endif // DEBUG
}


// The one and only CEfxMfcApp object

CEfxMfcApp theApp;


// CEfxMfcApp initialization

BOOL CEfxMfcApp::InitInstance()
{
	CWinApp::InitInstance();
	AfxEnableControlContainer();
	CoInitialize(NULL);

	WNDCLASS wndcls;
	ZeroMemory(&wndcls, sizeof(WNDCLASS));
	wndcls.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
	wndcls.lpfnWndProc = ::DefWindowProc; 
	wndcls.hInstance = AfxGetInstanceHandle();
	wndcls.hIcon = nullptr;
	wndcls.hCursor = nullptr;
	wndcls.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wndcls.lpszMenuName = NULL;
	wndcls.lpszClassName = _T("EfxMfc Window Class");
	if (!AfxRegisterClass(&wndcls)) {
		printf("Class Registration Failed!\n");
		return FALSE;
	}

	UINT _seqNo = InterlockedExchangeAdd(&m_efxSeqNo, 1);
	//printf("_seqNo = %d, m_efxSeqNo = %d\n", _seqNo, m_efxSeqNo);
	if (!m_wndEfxMain.CreateEx(0, wndcls.lpszClassName, _T("EfxMfc Main"), WS_POPUP, CRect(0, 0, 0, 0), nullptr, 0)) {
		printf("Create Window Failed!(Err: %x)\n", GetLastError());
		return FALSE;
	}
	m_pMainWnd = &m_wndEfxMain;

	m_pEfxWnd = new CEfxWnd();
	if (!m_pEfxWnd->Create(&m_wndEfxMain, _seqNo))
		return FALSE;
	m_mapEfxWnd.SetAt(_seqNo, m_pEfxWnd);

	return TRUE;
}

int CEfxMfcApp::ExitInstance()
{
	//printf("CEfxMfcApp::ExitInstance()\n");
	return CWinApp::ExitInstance();
}

void CEfxMfcApp::SetSysMsgCallback(efxSysMsgCB fnSysMsg)
{
	if (m_pEfxWnd)
		m_pEfxWnd->m_fnSysMsg = fnSysMsg;
}

bool CEfxMfcApp::LoadStockMaster()
{
	CString strFilePath(m_strEfxDir);
	strFilePath += _T("Common\\master\\kospi_code.mst");

	CFile file;
	CFileException ex;
	if (!file.Open(strFilePath, CFile::modeRead | CFile::typeBinary, &ex)) {
		TCHAR szError[256];
		ex.GetErrorMessage(szError, 256);
		_putts(szError);
		return false;
	}

	int sequence = 0;
	m_arStockMaster.SetSize(0, 4000);
	int nRead;
	char szBuff[290] = { 0 };
	CStringA str, strToday;
	CTime now = CTime::GetCurrentTime();
	strToday.Format("%4d%02d%02d", now.GetYear(), now.GetMonth(), now.GetDay());
	CStringW strStockName;
	efxStockMasterItem item;
	ZeroMemory(&item, sizeof(item));
	item.marketType = efxMarketType::KOSPI;
	while (1) {
		nRead = file.Read(szBuff, 289);
		if (!nRead)
			break;

		item.seqNo = sequence++;
		str.SetString(szBuff, 9);
		str.TrimRight();
		strcpy_s(item.stockCode, sizeof(item.stockCode), (LPCSTR)str);
		strncpy_s(item.stockStdCode, sizeof(item.stockStdCode), &szBuff[9], 12);
		str.SetString(&szBuff[21], 40);
		str.TrimRight();
		strStockName = (LPCWSTR)CA2W(str);
		WideCharToUtf8(item.stockName, sizeof(item.stockName), strStockName);
		str.SetString(&szBuff[79], 1);
		item.kospi200Sector = (char)atoi(str);
		item.isKospi100 = (szBuff[80] == 'Y');
		item.isKospi50 = (szBuff[81] == 'Y');
		item.isETF = (szBuff[83] != ' ');
		item.isAcquisition = (szBuff[90] == 'Y');
		item.investInfo.isSuspension = (szBuff[121] == 'Y');
		item.investInfo.isClearanceSale = (szBuff[122] == 'Y');
		item.investInfo.isManagement = (szBuff[123] == 'Y');
		str.SetString(&szBuff[124], 2);
		switch (atoi(str)) {
		case 0: item.investInfo.marketWarnCode = efxMarketWarning::None; break;
		case 1: item.investInfo.marketWarnCode = efxMarketWarning::Caution; break;
		case 2: item.investInfo.marketWarnCode = efxMarketWarning::Warning; break;
		case 3: item.investInfo.marketWarnCode = efxMarketWarning::Danger; break;
		default:
			item.investInfo.marketWarnCode = efxMarketWarning::None;
			ASSERT(false);
			break;
		}
		item.investInfo.isMarketWarning = (szBuff[126] == 'Y');
		item.investInfo.isInsincerityNotice = (szBuff[127] == 'Y');
		item.investInfo.isBackdoorListing = (szBuff[128] == 'Y');
		item.investInfo.isCreditable = (szBuff[138] == 'Y');
		str.SetString(&szBuff[135], 3);
		item.investInfo.marginRate = (short)atoi(str);
		str.SetString(&szBuff[154], 12);
		item.investInfo.parValue = atoi(str);
		strncpy_s(item.investInfo.listingDate, sizeof(item.investInfo.listingDate), &szBuff[166], 8);
		str.SetString(&szBuff[174], 15);
		item.investInfo.listingCount = _atoi64(str) * 1000;
		item.investInfo.isNewListing = (strToday == item.investInfo.listingDate);
		str.SetString(&szBuff[189], 21);
		item.investInfo.capital = _atoi64(str);
		item.investInfo.isShortSelling = (szBuff[220] == 'Y');
		item.investInfo.isAbnormalRise = (szBuff[221] == 'Y');
		item.isKRX300 = (szBuff[222] == 'Y');
		str.SetString(&szBuff[224], 9);
		item.investInfo.sales = atoi(str);
		str.SetString(&szBuff[233], 9);
		item.investInfo.operatingProfit = atoi(str);
		str.SetString(&szBuff[242], 9);
		item.investInfo.ordinaryProfit = atoi(str);
		str.SetString(&szBuff[251], 5);
		item.investInfo.netIncome = atoi(str);
		str.SetString(&szBuff[256], 9);
		item.investInfo.ROE = (float)atof(str);
		strncpy_s(item.investInfo.baseYearMonth, sizeof(item.investInfo.baseYearMonth), &szBuff[265], 8);
		str.SetString(&szBuff[273], 9);
		item.investInfo.predayMarketCap = atoi(str);
		item.investInfo.isCreditLimtOver = (szBuff[285] == 'Y');
		item.investInfo.isLoanable = (szBuff[286] == 'Y');
		item.investInfo.isStockLoanable = (szBuff[287] == 'Y');
		m_arStockMaster.Add(item);
		m_mapStockMstCode.SetAt(item.stockCode, &m_arStockMaster.GetAt(item.seqNo));
		m_mapStockMstName.SetAt(strStockName, &m_arStockMaster.GetAt(item.seqNo));
	}
	file.Close();

	strFilePath = m_strEfxDir;
	strFilePath += _T("Common\\master\\kosdaq_code.mst");
	if (!file.Open(strFilePath, CFile::modeRead | CFile::typeBinary, &ex)) {
		TCHAR szError[256];
		ex.GetErrorMessage(szError, 256);
		_putts(szError);
		return false;
	}

	ZeroMemory(&item, sizeof(item));
	item.marketType = efxMarketType::KOSDAQ;
	while (1) {
		nRead = file.Read(szBuff, 283);
		if (!nRead)
			break;

		item.seqNo = sequence++;
		str.SetString(szBuff, 9);
		str.TrimRight();
		strcpy_s(item.stockCode, sizeof(item.stockCode), (LPCSTR)str);
		strncpy_s(item.stockStdCode, sizeof(item.stockStdCode), &szBuff[9], 12);
		str.SetString(&szBuff[21], 40);
		str.TrimRight();
		strStockName = (LPCWSTR)CA2W(str);
		WideCharToUtf8(item.stockName, sizeof(item.stockName), strStockName);
		item.isVenture = (szBuff[76] == 'Y');
		item.isKRX100 = (szBuff[78] == 'Y');
		item.isAcquisition = (szBuff[83] == 'Y');
		item.investInfo.isSuspension = (szBuff[116] == 'Y');
		item.investInfo.isClearanceSale = (szBuff[117] == 'Y');
		item.investInfo.isManagement = (szBuff[118] == 'Y');
		str.SetString(&szBuff[119], 2);
		switch (atoi(str)) {
		case 0: item.investInfo.marketWarnCode = efxMarketWarning::None; break;
		case 1: item.investInfo.marketWarnCode = efxMarketWarning::Caution; break;
		case 2: item.investInfo.marketWarnCode = efxMarketWarning::Warning; break;
		case 3: item.investInfo.marketWarnCode = efxMarketWarning::Danger; break;
		default:
			item.investInfo.marketWarnCode = efxMarketWarning::None;
			ASSERT(false);
			break;
		}
		item.investInfo.isMarketWarning = (szBuff[121] == 'Y');
		item.investInfo.isInsincerityNotice = (szBuff[122] == 'Y');
		item.investInfo.isBackdoorListing = (szBuff[123] == 'Y');
		item.investInfo.isCreditable = (szBuff[133] == 'Y');
		str.SetString(&szBuff[130], 3);
		item.investInfo.marginRate = (short)atoi(str);
		str.SetString(&szBuff[149], 12);
		item.investInfo.parValue = atoi(str);
		strncpy_s(item.investInfo.listingDate, sizeof(item.investInfo.listingDate), &szBuff[161], 8);
		str.SetString(&szBuff[169], 15);
		item.investInfo.listingCount = _atoi64(str) * 1000;
		item.investInfo.isNewListing = (strToday == item.investInfo.listingDate);
		str.SetString(&szBuff[184], 21);
		item.investInfo.capital = _atoi64(str);
		item.investInfo.isShortSelling = (szBuff[215] == 'Y');
		item.investInfo.isAbnormalRise = (szBuff[216] == 'Y');
		item.isKRX300 = (szBuff[217] == 'Y');
		str.SetString(&szBuff[218], 9);
		item.investInfo.sales = atoi(str);
		str.SetString(&szBuff[227], 9);
		item.investInfo.operatingProfit = atoi(str);
		str.SetString(&szBuff[236], 9);
		item.investInfo.ordinaryProfit = atoi(str);
		str.SetString(&szBuff[245], 5);
		item.investInfo.netIncome = atoi(str);
		str.SetString(&szBuff[250], 9);
		item.investInfo.ROE = (float)atof(str);
		strncpy_s(item.investInfo.baseYearMonth, sizeof(item.investInfo.baseYearMonth), &szBuff[259], 8);
		str.SetString(&szBuff[267], 9);
		item.investInfo.predayMarketCap = atoi(str);
		item.investInfo.isCreditLimtOver = (szBuff[279] == 'Y');
		item.investInfo.isLoanable = (szBuff[280] == 'Y');
		item.investInfo.isStockLoanable = (szBuff[281] == 'Y');
		m_arStockMaster.Add(item);
		m_mapStockMstCode.SetAt(item.stockCode, &m_arStockMaster.GetAt(item.seqNo));
		m_mapStockMstName.SetAt(strStockName, &m_arStockMaster.GetAt(item.seqNo));
	}
	file.Close();

#ifdef DEBUG
	printf("LoadStockMaster(): Count = %d, memSize = %d\n", sequence, sizeof(item) * m_arStockMaster.GetSize());
#endif // DEBUG

	return true;
}

void CEfxMfcApp::InsertEfxWnd(UINT uID, CEfxWnd* pEfxWnd)
{
	m_mapEfxWnd.SetAt(uID, pEfxWnd);
}

void CEfxMfcApp::OnEfxExit()
{
	if (m_pEfxWnd)
		m_pEfxWnd->OnReceiveSysMessage(4);

	UINT id;
	CEfxWnd* pEfxWnd;
	POSITION pos = m_mapEfxWnd.GetStartPosition();
	while (pos) {
		m_mapEfxWnd.GetNextAssoc(pos, id, pEfxWnd);
		pEfxWnd->DestroyWindow();
		delete pEfxWnd;
	}
	m_mapEfxWnd.RemoveAll();
	m_wndEfxMain.DestroyWindow();
}


// EfxMfc Impl

int efxInit(LPCSTR lpszEFXDir, efxSysMsgCB fnSysMsg)
{
	if (!IsUserAnAdmin()) {
		printf("EfxInit: Administrative Privileges Required!\n");
		return -1;
	}
	if (!lpszEFXDir || !lpszEFXDir[0])
		theApp.m_strEfxDir = _T("C:\\eFriend Expert");
	else {
		WCHAR wszEfxDir[MAX_PATH];
		Utf8ToWideChar(wszEfxDir, _countof(wszEfxDir), lpszEFXDir);
		theApp.m_strEfxDir = wszEfxDir;
	}
	if (!theApp.m_strEfxDir.IsEmpty() && theApp.m_strEfxDir.Right(1) != _T("\\"))
		theApp.m_strEfxDir += _T("\\");
	theApp.SetSysMsgCallback(fnSysMsg);
	if (!theApp.LoadStockMaster())
		printf("EfxInit: LoadStockMaster() error!\n");

	return 0;
}

void efxExit(void)
{
	theApp.OnEfxExit();
}

int efxProcessMessage(UINT uMilliSec)
{
	MSG msg;
	int nMsgCount = 0;
	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
		if (msg.message == WM_QUIT)
			return 0;
		TranslateMessage(&msg);
		DispatchMessage(&msg);
		++nMsgCount;
	}
	Sleep(uMilliSec);
	return nMsgCount;
}

void efxMessageLoop(void)
{
	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
}

void efxQuit(int nExitCode)
{
	PostQuitMessage(nExitCode);
}

efxStockMasterItem* efxFindStockMaster(LPCSTR lpszStockCode)
{
	return theApp.FindStockMaster(lpszStockCode);
}

efxStockMasterItem* efxGetStockMaster(int seqNo)
{
	return theApp.GetStockMasterAt(seqNo);
}

HANDLE efxNewControl(UINT uCtrlID, efxEventCB fnRecvData, efxEventCB fnRecvRealData, efxEventCB fnError)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UINT _seqNo = InterlockedExchangeAdd(&CEfxMfcApp::m_efxSeqNo, 1);
	auto pEfxWnd = new CEfxWnd();
	if (!pEfxWnd->Create(theApp.GetMainWnd(), uCtrlID, fnRecvData, fnRecvRealData, fnError))
		return nullptr;
	theApp.InsertEfxWnd(_seqNo, pEfxWnd);
	return pEfxWnd;
}

int efxGetAccountCount(void)
{
	auto pEfxWnd = theApp.GetEfxWnd();
	if (pEfxWnd)
		return pEfxWnd->GetAccountCount();
	return 0;
}

int efxGetAccount(int nIdx, LPSTR lpszAccount)
{
	auto pEfxWnd = theApp.GetEfxWnd();
	if (!pEfxWnd)
		return 0;
	CString strAccount = pEfxWnd->GetAccount(nIdx);
	size_t buff_len = strAccount.GetLength() + 1;
	return WideCharToUtf8(lpszAccount, buff_len, strAccount);
}

int efxGetAccountBrcode(LPCSTR lpszAcntNo, LPSTR lpszBrcode)
{
	auto pEfxWnd = theApp.GetEfxWnd();
	if (!pEfxWnd)
		return 0;
	WCHAR wszTemp[32] = { 0 };
	int nLen = Utf8ToWideChar(wszTemp, _countof(wszTemp), lpszAcntNo);
	CString strBrcode = pEfxWnd->GetAccountBrcode(wszTemp);
	size_t buff_len = strBrcode.GetLength() + 1;
	return WideCharToUtf8(lpszBrcode, buff_len, strBrcode);
}

int efxGetEncryptPassword(LPCSTR lpszPwd, LPSTR lpszEncrypt)
{
	auto pEfxWnd = theApp.GetEfxWnd();
	if (!pEfxWnd)
		return 0;
	WCHAR wszTemp[256] = { 0 };
	int nLen = Utf8ToWideChar(wszTemp, _countof(wszTemp), lpszPwd);
	CString strEncrypt = pEfxWnd->GetEncryptPassword(wszTemp);
	size_t buff_len = strEncrypt.GetLength() + 1;
	return WideCharToUtf8(lpszEncrypt, buff_len, strEncrypt);
}

void efxAboutBox(void)
{
	auto pEfxWnd = theApp.GetEfxWnd();
	if (pEfxWnd)
		pEfxWnd->AboutBox();
}

void efxSetSingleData(HANDLE hCtrl, int nIndex, LPCSTR lpszData)
{
	//printf("lpszData: %s\n", lpszData);
	auto pEfxWnd = reinterpret_cast<CEfxWnd*>(hCtrl);
	wchar_t wszData[256] = { 0 };
	Utf8ToWideChar(wszData, _countof(wszData), lpszData);
	pEfxWnd->SetSingleData(nIndex, wszData);
}

void efxRequestData(HANDLE hCtrl, LPCSTR lpszQryName, LPCSTR lpszParam)
{
	auto pEfxWnd = reinterpret_cast<CEfxWnd*>(hCtrl);
	wchar_t wszQryName[16] = { 0 };
	Utf8ToWideChar(wszQryName, _countof(wszQryName), lpszQryName);
	pEfxWnd->RequestData(wszQryName);
	int nRqId = pEfxWnd->GetSendRqID();
	pEfxWnd->GetReqIdTbl().SetItem(nRqId, lpszQryName, lpszParam);
}

int efxIsMoreNextData(HANDLE hCtrl)
{
	auto pEfxWnd = reinterpret_cast<CEfxWnd*>(hCtrl);
	return pEfxWnd->IsMoreNextData();
}

void efxRequestNextData(HANDLE hCtrl, LPCSTR lpszQryName)
{
	auto pEfxWnd = reinterpret_cast<CEfxWnd*>(hCtrl);
	wchar_t wszQryName[16] = { 0 };
	Utf8ToWideChar(wszQryName, _countof(wszQryName), lpszQryName);
	pEfxWnd->RequestNextData(wszQryName);
}

int efxGetSingleFieldCount(HANDLE hCtrl)
{
	auto pEfxWnd = reinterpret_cast<CEfxWnd*>(hCtrl);
	return pEfxWnd->GetSingleFieldCount();
}

int efxGetSingleData(HANDLE hCtrl, LPSTR lpszData, int nIndex, int nAttrType)
{
	auto pEfxWnd = reinterpret_cast<CEfxWnd*>(hCtrl);
	CString strData;
	pEfxWnd->GetSingleData(strData, nIndex, nAttrType);
	return WideCharToUtf8(lpszData, strData.GetLength() + 1, strData);
}
