use libc::*;
use std::ptr;
use std::ffi::CStr;


type EfxEventCB = unsafe extern "C" fn(*const c_void, c_uint, *const c_char);
type EfxSysMsgCB = unsafe extern "C" fn(*const c_void, c_uint, c_int);

#[link(name = "EfxMfc", kind = "static")]
#[allow(dead_code)]
extern {
    fn efxInit(efxDir:*const u8, sysMsgCB:EfxSysMsgCB) -> c_int;
    fn efxExit();
    fn efxProcessMessage(milliSec:c_uint) -> c_int;
	fn efxMessageLoop();
    fn efxQuit(exit_code:c_int);

    fn efxNewControl(id:c_uint, recvData:Option<EfxEventCB>, recvRealData:Option<EfxEventCB>, recvError:Option<EfxEventCB>) -> *const c_void;
    fn efxGetAccountCount() -> c_int;
    fn efxGetAccount(idx:c_int, szAccount:*mut u8) -> c_int;
    fn efxGetAccountBrcode(acnt_no:*const u8, brcode:*mut u8) -> c_int;
	fn efxGetEncryptPassword(pwd:*const u8, enc_pwd:*mut u8) -> c_int;
    fn efxAboutBox();

    fn efxSetSingleData(handle:*const c_void, field_idx:c_int, data:*const u8);
    fn efxRequestData(handle:*const c_void, qry_name:*const u8, param:*const u8);
    fn efxIsMoreNextData(handle:*const c_void) -> c_int;
	fn efxRequestNextData(handle:*const c_void, qry_name:*const u8);

	fn efxGetSingleFieldCount(handle:*const c_void) -> c_int;
	fn efxGetSingleData(handle:*const c_void, s_data:*mut u8, field_idx:c_int, attr_type:c_int) -> c_int;
}

#[allow(non_snake_case)]
unsafe extern "C" fn OnRecvSysMsg(_handle:*const c_void, ctrl_id:c_uint, sys_msg:c_int)
{
    println!("OnRecvSysMsg({}, {})", ctrl_id, sys_msg);
}

#[allow(non_snake_case)]
unsafe extern "C" fn OnRecvData(handle:*const c_void, ctrl_id:c_uint, param:*const c_char)
{
    let str_param = CStr::from_ptr(param);
    let stock_code = str_param.to_str().unwrap();
    println!("OnRecvData({}, \"{}\")", ctrl_id, stock_code);
    let field_cnt = efxGetSingleFieldCount(handle);
    println!("field_cnt = {}", field_cnt);
    let mut data:Vec<u8> = Vec::with_capacity(256);
    data.resize(data.capacity() - 1, 0);
    let _len = efxGetSingleData(handle, data.as_mut_ptr(), 11, 0);
    //println!("len = {}", len);
    let s_data = String::from_utf8_lossy(&data);
    println!("{} 현재가: {}원", stock_code, s_data);
    efxQuit(0);
}

#[allow(non_snake_case)]
#[allow(dead_code)]
unsafe extern "C" fn OnRecvRealData(_handle:*const c_void, ctrl_id:c_uint, _param:*const c_char)
{
    println!("OnRecvRealData({})", ctrl_id);
}


fn main() {
    println!("Hello, world!");
    let mut s = String::new();
    unsafe {
        let _ret = efxInit(ptr::null(), OnRecvSysMsg);
        let acc_cnt = efxGetAccountCount();
        println!("AccountCount = {}", acc_cnt);
        /*s.push_str("0123456789\x00");
        for i in 0..acc_cnt {
            efxGetAccount(i, s.as_mut_ptr());
            println!("account[{}]: {}", i, s);
        }*/
        s.clear();
        for _i in 0..100 { s.push('\0') };
        let len = efxGetEncryptPassword("12345\x00".as_ptr(), s.as_mut_ptr());
        s.truncate(len as usize);
        println!("Encrypt: {} (len: {})\n", s, len);
        let efx1 = efxNewControl(100, Some(OnRecvData), None, None);
        let stock_code = String::from("149950\x00");
        efxSetSingleData(efx1, 0, "J\x00".as_ptr());
        efxSetSingleData(efx1, 1, stock_code.as_ptr());
        efxRequestData(efx1, "SCP\x00".as_ptr(), stock_code.as_ptr());
        println!("RequestData(\"SCP\", \"{}\")", stock_code);
        //efxAboutBox();
    };
    unsafe {
        efxMessageLoop();
        efxExit();
    };
}
